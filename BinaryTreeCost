/**
 * 
 */

/**
 * 
 */
public class BinaryTreeCost<T> {
    private Node<Seminar> root;

    public BinaryTreeCost() {
        // instantiate root node
        root = null;
    }


    // ----------------------------------------------------------
    /**
     * 139
     * Calculate the size of this binary tree.
     * 140
     * 
     * 141
     * 
     * @return The size of this tree.
     *         142
     */
    public int size(Node<T> root) {

        int size = 1;

        if (root.getLeft() == null && root.getRight() == null) {

            return size;

        }

        if (root.getLeft() != null) {

            size = size + size(root.getLeft());

        }

        if (root.getRight() != null) {

            size = size + size(root.getRight());

        }

        return size;

        // Base case: current node has 0 children

        // Recursive Case 1: current node has 1 child on the left

        // Recursive Case 2: current node has 1 child on the right

        // Recursive Case 3: current node has 2 children

    }


    public void insert(Seminar val) {
        root = insertRec(root, val);
    }


    private Node<Seminar> insertRec(Node<Seminar> root, Seminar val) {
        if (root == null) {
            root = new Node<Seminar>(val);
            // System.out.println(val);
            return root;
        }

        if (val.id() == root.getElement().id()) {
            // collision
            return null;
        }
        else if (val.cost() < root.getElement().cost()) {
            root.setLeft(insertRec(root.getLeft(), val));
        }
        else {
            root.setRight(insertRec(root.getRight(), val));
        }
        // System.out.println(val);
        return root;
    }


    public Node<Seminar> returnRoot() {
        return root;
    }


    // always pass in 1 for initial inOrderSearch call to account for root node
    public int inOrderSearch(
        Node<Seminar> root,
        int low,
        int high,
        int nodeCount,
        boolean groot) {

        if (root == null) {
            return nodeCount;
        }

        if (root.getElement().cost() >= low && root.getElement().cost() <= high
            && groot) {
            System.out.println(root.getElement());
        }

        if (root.getLeft() != null) {

            nodeCount++;

            if (root.getLeft().getElement().cost() >= low && root.getLeft().getElement()
                .cost() <= high) {

                System.out.println(root.getLeft().getElement());

            }

            // only included the else statements in the key tree
            nodeCount = inOrderSearch(root.getLeft(), low, high, nodeCount,
                false);

        }

        if (root.getRight() != null) {

            nodeCount++;

            if (root.getRight().getElement().cost() >= low && root.getRight().getElement()
                .cost() <= high) {

                System.out.println(root.getRight().getElement());

            }

            nodeCount = inOrderSearch(root.getRight(), low, high, nodeCount,
                false);

        }
        return nodeCount;

    }


    // ----------------------------------------------------------
    /**
     * 168
     * Calculate the height of this binary tree.
     * 169
     * The height is longest path from the root to
     * 170
     * a leaf node.
     * 171
     * Examples:
     * 172
     * A A A
     * 173
     * / / \
     * 174
     * B B C
     * 175
     * Height: 1 2 2
     * 176
     * 
     * 177
     * 
     * @return The height of this tree.
     *         178
     */

    public int height(Node<T> root) {

        int height = 1; // base case returns 1 for height

        if (root.getLeft() == null && root.getRight() == null) {

            return 1;

        }

        if (root.getLeft() != null) {

            height = Math.max(height, 1 + height(root.getLeft()));

        }

        if (root.getRight() != null) {

            height = Math.max(height, 1 + height(root.getRight()));

        }

        return height;

    }


    // ----------------------------------------------------------
    /**
     * 198
     * Generate a string containing the "printed version" of this binary
     * 199
     * tree using a pre-order traversal. The tree's contents are printed
     * 200
     * as a parenthesized list.
     * 201
     * 
     * 202
     * Example: (A(B)(C))
     * 203
     * Visually: A
     * 204
     * / \ Traversal: A B C
     * 205
     * B C
     * 206
     * 
     * 207
     * 
     * @return a printable representation of this tree's contents, using
     *         208
     *         a pre-order traversal.
     *         209
     */

 


    // ----------------------------------------------------------
    /**
     * 232
     * Generate a string containing the "printed version" of this binary
     * 233
     * tree using a in-order traversal. The tree's contents are printed as
     * 234
     * a parenthesized list.
     * 235
     * 
     * 236
     * Example: ((B)A(C))
     * 237
     * Visually: A
     * 238
     * / \ Traversal: B A C
     * 239
     * B C
     * 240
     * 
     * 241
     * 
     * @return a printable representation of this tree's contents, using
     *         242
     *         an in-order traversal.
     *         243
     */

    public String toInOrderString(Node<T> root) {

        StringBuilder builder = new StringBuilder();

        builder.append("(");

        if (root.getLeft() != null) {

            builder.append(toInOrderString(root.getLeft()));

        }

        builder.append(root.getElement());

        if (root.getRight() != null) {

            builder.append(toInOrderString(root.getRight()));
        }

        builder.append(")");

        return builder.toString();

    }


    // ----------------------------------------------------------
    /**
     * 263
     * Generate a string containing the "printed version" of this binary
     * 264
     * tree using a post-order traversal. The tree's contents are printed
     * 265
     * as a parenthesized list.
     * 266
     * 
     * 267
     * For example, if a tree containing the data
     * 268
     * value A has a left child containing B and a right child containing C,
     * 269
     * it would be printed as ((B)(C)A).
     * 270
     * Visually: A
     * 271
     * / \ Traversal: B C A
     * 272
     * B C
     * 273
     * 
     * 274
     * The parentheses directly reflect
     * 275
     * the structure of each node in the tree.
     * 276
     * 
     * 277
     * 
     * @return a printable representation of this tree's contents, using
     *         278
     *         a post-order traversal.
     *         279
     */

 
}
